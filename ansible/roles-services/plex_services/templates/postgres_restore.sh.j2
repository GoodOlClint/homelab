#!/bin/bash
#
# PostgreSQL Restore Script for Plex Services
# Restores PostgreSQL databases from local or remote (SMB) backup
#
set -euo pipefail

# Configuration
BACKUP_DIR="/docker/postgres_backups"
LOG_FILE="/var/log/postgres_restore.log"

# PostgreSQL connection details
POSTGRES_USER="{{ postgres_user | default('qstick') }}"
POSTGRES_PASSWORD="{{ postgres_password | default('qstick') }}"
POSTGRES_HOST="localhost"
POSTGRES_PORT="5432"

# SMB Configuration
{% if plex_backup_smb_server is defined %}
SMB_SERVER="{{ plex_backup_smb_server }}"
SMB_SHARE="{{ plex_backup_smb_share }}"
SMB_USER="{{ plex_backup_smb_user }}"
SMB_PASS="{{ plex_backup_smb_pass }}"
SMB_DOMAIN="{{ plex_backup_smb_domain | default('') }}"
REMOTE_BACKUP_PATH="{{ postgres_backup_remote_path | default('plex_services/postgres_backups') }}"
SMB_ENABLED=true
{% else %}
SMB_ENABLED=false
{% endif %}

# Usage function
usage() {
    echo "Usage: $0 [OPTIONS]"
    echo "Options:"
    echo "  -d, --database DATABASE    Database name to restore"
    echo "  -f, --file BACKUP_FILE     Specific backup file to restore"
    echo "  -l, --latest               Restore latest backup for database"
    echo "  -r, --remote               Download latest backup from remote SMB share"
    echo "  -g, --globals              Restore global objects (roles, tablespaces)"
    echo "  -a, --all                  Restore all databases (with globals)"
    echo "  --hydrate                  Restore globals + schema only (no data)"
    echo "  --list-backups             List available backups"
    echo "  --list-remote              List available remote backups"
    echo "  -h, --help                 Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0 -d radarr-main -l                    # Restore latest local backup"
    echo "  $0 -d radarr-main -r                    # Download and restore latest remote backup"
    echo "  $0 -f /path/to/backup.dump             # Restore specific backup file"
    echo "  $0 -g -l                                # Restore latest globals backup"
    echo "  $0 -a -l                                # Restore ALL databases (full restore)"
    echo "  $0 -a -r                                # Restore ALL from remote"
    echo "  $0 --hydrate -l                         # Restore globals + schema only"
    echo "  $0 --list-backups                       # List local backups"
    echo "  $0 --list-remote                        # List remote backups"
    echo ""
    echo "Note: --all automatically restores globals first, then all databases"
    echo "      --hydrate creates empty databases with correct structure"
    echo "      pg_restore is used for .dump files (recommended)"
    echo "      psql is used for legacy .sql.gz files"
    exit 1
}

# Logging function
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a "$LOG_FILE"
}

# Error handling
error_exit() {
    log "ERROR: $1"
    exit 1
}

# List local backups
list_backups() {
    log "Available local backups:"
    if [ -d "$BACKUP_DIR" ]; then
        echo "=== Database Backups ==="
        find "$BACKUP_DIR" -name "*.dump" -type f -exec basename {} \; | sort
        echo ""
        echo "=== Global Objects Backups ==="
        find "$BACKUP_DIR" -name "postgres_globals_*.sql.gz" -type f -exec basename {} \; | sort
        echo ""
        echo "=== Legacy SQL Backups ==="
        find "$BACKUP_DIR" -name "*.sql.gz" ! -name "postgres_globals_*" -type f -exec basename {} \; | sort
    else
        log "No local backup directory found"
    fi
}

# List remote backups
list_remote_backups() {
    if [ "$SMB_ENABLED" != true ]; then
        error_exit "SMB is not configured"
    fi
    
    log "Available remote backups:"
    if [ -n "$SMB_DOMAIN" ]; then
        smbclient "//$SMB_SERVER/$SMB_SHARE" -U "$SMB_DOMAIN/$SMB_USER%$SMB_PASS" -c "cd \"$REMOTE_BACKUP_PATH\"; ls *.dump" 2>/dev/null | grep "\.dump$" | awk '{print $1}' || log "No remote .dump backups found"
        smbclient "//$SMB_SERVER/$SMB_SHARE" -U "$SMB_DOMAIN/$SMB_USER%$SMB_PASS" -c "cd \"$REMOTE_BACKUP_PATH\"; ls *.sql.gz" 2>/dev/null | grep "\.sql\.gz$" | awk '{print $1}' || log "No remote .sql.gz backups found"
    else
        smbclient "//$SMB_SERVER/$SMB_SHARE" -U "$SMB_USER%$SMB_PASS" -c "cd \"$REMOTE_BACKUP_PATH\"; ls *.dump" 2>/dev/null | grep "\.dump$" | awk '{print $1}' || log "No remote .dump backups found"
        smbclient "//$SMB_SERVER/$SMB_SHARE" -U "$SMB_USER%$SMB_PASS" -c "cd \"$REMOTE_BACKUP_PATH\"; ls *.sql.gz" 2>/dev/null | grep "\.sql\.gz$" | awk '{print $1}' || log "No remote .sql.gz backups found"
    fi
}

# Download backup from remote
download_remote_backup() {
    local database="$1"
    local backup_file="$2"
    
    if [ "$SMB_ENABLED" != true ]; then
        error_exit "SMB is not configured"
    fi
    
    log "Downloading backup from remote: $backup_file"
    mkdir -p "$BACKUP_DIR"
    
    if [ -n "$SMB_DOMAIN" ]; then
        smbclient "//$SMB_SERVER/$SMB_SHARE" -U "$SMB_DOMAIN/$SMB_USER%$SMB_PASS" -c "cd \"$REMOTE_BACKUP_PATH\"; get \"$backup_file\" \"$BACKUP_DIR/$backup_file\""
    else
        smbclient "//$SMB_SERVER/$SMB_SHARE" -U "$SMB_USER%$SMB_PASS" -c "cd \"$REMOTE_BACKUP_PATH\"; get \"$backup_file\" \"$BACKUP_DIR/$backup_file\""
    fi
    
    if [ $? -eq 0 ]; then
        log "Successfully downloaded backup: $BACKUP_DIR/$backup_file"
        echo "$BACKUP_DIR/$backup_file"
    else
        error_exit "Failed to download backup from remote"
    fi
}

# Find latest backup for database
find_latest_backup() {
    local database="$1"
    local location="$2"  # "local" or "remote"
    
    if [ "$location" = "local" ]; then
        if [ -d "$BACKUP_DIR" ]; then
            # First try to find .dump files (preferred)
            local dump_file=$(find "$BACKUP_DIR" -name "${database}_*.dump" -type f | sort | tail -n1)
            if [ -n "$dump_file" ]; then
                echo "$dump_file"
                return
            fi
            # Fall back to .sql.gz files (legacy)
            find "$BACKUP_DIR" -name "${database}_*.sql.gz" -type f | sort | tail -n1
        fi
    elif [ "$location" = "remote" ]; then
        if [ "$SMB_ENABLED" != true ]; then
            error_exit "SMB is not configured"
        fi
        
        local remote_files
        if [ -n "$SMB_DOMAIN" ]; then
            # Try .dump files first
            remote_files=$(smbclient "//$SMB_SERVER/$SMB_SHARE" -U "$SMB_DOMAIN/$SMB_USER%$SMB_PASS" -c "cd \"$REMOTE_BACKUP_PATH\"; ls ${database}_*.dump" 2>/dev/null | grep "${database}_.*\.dump$" | awk '{print $1}' | sort | tail -n1 || true)
            # Fall back to .sql.gz
            if [ -z "$remote_files" ]; then
                remote_files=$(smbclient "//$SMB_SERVER/$SMB_SHARE" -U "$SMB_DOMAIN/$SMB_USER%$SMB_PASS" -c "cd \"$REMOTE_BACKUP_PATH\"; ls ${database}_*.sql.gz" 2>/dev/null | grep "${database}_.*\.sql\.gz$" | awk '{print $1}' | sort | tail -n1 || true)
            fi
        else
            # Try .dump files first
            remote_files=$(smbclient "//$SMB_SERVER/$SMB_SHARE" -U "$SMB_USER%$SMB_PASS" -c "cd \"$REMOTE_BACKUP_PATH\"; ls ${database}_*.dump" 2>/dev/null | grep "${database}_.*\.dump$" | awk '{print $1}' | sort | tail -n1 || true)
            # Fall back to .sql.gz
            if [ -z "$remote_files" ]; then
                remote_files=$(smbclient "//$SMB_SERVER/$SMB_SHARE" -U "$SMB_USER%$SMB_PASS" -c "cd \"$REMOTE_BACKUP_PATH\"; ls ${database}_*.sql.gz" 2>/dev/null | grep "${database}_.*\.sql\.gz$" | awk '{print $1}' | sort | tail -n1 || true)
            fi
        fi
        
        if [ -n "$remote_files" ]; then
            echo "$remote_files"
        fi
    fi
}

# Restore database from backup
restore_database() {
    local backup_file="$1"
    local schema_only="${2:-false}"
    local database_name
    
    if [ ! -f "$backup_file" ]; then
        error_exit "Backup file not found: $backup_file"
    fi
    
    # Detect backup format and extract database name
    if [[ "$backup_file" =~ \.dump$ ]]; then
        # Custom format (.dump)
        database_name=$(basename "$backup_file" | sed 's/_[0-9]\{8\}_[0-9]\{6\}\.dump$//')
        BACKUP_FORMAT="custom"
    elif [[ "$backup_file" =~ \.sql\.gz$ ]]; then
        # Legacy compressed SQL (.sql.gz)
        database_name=$(basename "$backup_file" | sed 's/_[0-9]\{8\}_[0-9]\{6\}\.sql\.gz$//')
        BACKUP_FORMAT="sql"
    else
        error_exit "Unknown backup format: $backup_file (expected .dump or .sql.gz)"
    fi
    
    if [ "$schema_only" = true ]; then
        log "Restoring database schema '$database_name' from backup: $backup_file (format: $BACKUP_FORMAT, SCHEMA ONLY)"
    else
        log "Restoring database '$database_name' from backup: $backup_file (format: $BACKUP_FORMAT)"
    fi
    
    # Check if PostgreSQL is running
    if ! PGPASSWORD="$POSTGRES_PASSWORD" psql -h "$POSTGRES_HOST" -p "$POSTGRES_PORT" -U "$POSTGRES_USER" -c '\q' 2>/dev/null; then
        error_exit "Cannot connect to PostgreSQL server"
    fi
    
    # Drop existing database if it exists (with confirmation)
    if PGPASSWORD="$POSTGRES_PASSWORD" psql -h "$POSTGRES_HOST" -p "$POSTGRES_PORT" -U "$POSTGRES_USER" -lqt | cut -d \| -f 1 | grep -qw "$database_name"; then
        log "WARNING: Database '$database_name' already exists and will be dropped!"
        read -p "Are you sure you want to continue? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            log "Restore cancelled by user"
            exit 0
        fi
        
        # Terminate existing connections
        PGPASSWORD="$POSTGRES_PASSWORD" psql -h "$POSTGRES_HOST" -p "$POSTGRES_PORT" -U "$POSTGRES_USER" -c "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = '$database_name' AND pid <> pg_backend_pid();" 2>/dev/null || true
        
        # Drop database
        PGPASSWORD="$POSTGRES_PASSWORD" dropdb -h "$POSTGRES_HOST" -p "$POSTGRES_PORT" -U "$POSTGRES_USER" "$database_name"
        log "Dropped existing database: $database_name"
    fi
    
    # Create new database
    PGPASSWORD="$POSTGRES_PASSWORD" createdb -h "$POSTGRES_HOST" -p "$POSTGRES_PORT" -U "$POSTGRES_USER" "$database_name"
    log "Created new database: $database_name"
    
    # Restore from backup based on format
    if [ "$schema_only" = true ]; then
        log "Restoring schema only (no data)..."
        if [ "$BACKUP_FORMAT" = "custom" ]; then
            # Use pg_restore with --schema-only for custom format
            PGPASSWORD="$POSTGRES_PASSWORD" pg_restore -h "$POSTGRES_HOST" -p "$POSTGRES_PORT" -U "$POSTGRES_USER" -d "$database_name" --no-owner --no-acl --schema-only "$backup_file"
        else
            log "WARNING: Schema-only restore not fully supported for .sql.gz files"
            log "Will restore full backup (use .dump format for schema-only support)"
            gunzip -c "$backup_file" | PGPASSWORD="$POSTGRES_PASSWORD" psql -h "$POSTGRES_HOST" -p "$POSTGRES_PORT" -U "$POSTGRES_USER" "$database_name"
        fi
    else
        log "Restoring data from backup..."
        if [ "$BACKUP_FORMAT" = "custom" ]; then
            # Use pg_restore for custom format (.dump files)
            PGPASSWORD="$POSTGRES_PASSWORD" pg_restore -h "$POSTGRES_HOST" -p "$POSTGRES_PORT" -U "$POSTGRES_USER" -d "$database_name" --no-owner --no-acl "$backup_file"
        else
            # Use psql for legacy SQL format (.sql.gz files)
            gunzip -c "$backup_file" | PGPASSWORD="$POSTGRES_PASSWORD" psql -h "$POSTGRES_HOST" -p "$POSTGRES_PORT" -U "$POSTGRES_USER" "$database_name"
        fi
    fi
    
    if [ $? -eq 0 ]; then
        if [ "$schema_only" = true ]; then
            log "Successfully restored database schema '$database_name' from backup"
        else
            log "Successfully restored database '$database_name' from backup"
        fi
    else
        error_exit "Failed to restore database '$database_name' from backup"
    fi
}

# Restore global objects
restore_globals() {
    local globals_file="$1"
    
    if [ ! -f "$globals_file" ]; then
        error_exit "Globals backup file not found: $globals_file"
    fi
    
    log "Restoring global objects (roles, tablespaces) from: $globals_file"
    
    # Check if PostgreSQL is running
    if ! PGPASSWORD="$POSTGRES_PASSWORD" psql -h "$POSTGRES_HOST" -p "$POSTGRES_PORT" -U "$POSTGRES_USER" -c '\q' 2>/dev/null; then
        error_exit "Cannot connect to PostgreSQL server"
    fi
    
    # Restore globals
    log "Restoring global objects..."
    gunzip -c "$globals_file" | PGPASSWORD="$POSTGRES_PASSWORD" psql -h "$POSTGRES_HOST" -p "$POSTGRES_PORT" -U "$POSTGRES_USER" postgres
    
    if [ $? -eq 0 ]; then
        log "Successfully restored global objects"
    else
        error_exit "Failed to restore global objects"
    fi
}

# Get list of all database backups
get_all_databases() {
    local location="$1"  # "local" or "remote"
    
    if [ "$location" = "local" ]; then
        if [ -d "$BACKUP_DIR" ]; then
            # Find all unique database names from backup files
            find "$BACKUP_DIR" -type f \( -name "*.dump" -o -name "*.sql.gz" \) ! -name "postgres_globals_*" -exec basename {} \; | sed 's/_[0-9]\{8\}_[0-9]\{6\}\.\(dump\|sql\.gz\)$//' | sort -u
        fi
    elif [ "$location" = "remote" ]; then
        if [ "$SMB_ENABLED" != true ]; then
            error_exit "SMB is not configured"
        fi
        
        local remote_files
        if [ -n "$SMB_DOMAIN" ]; then
            remote_files=$(smbclient "//$SMB_SERVER/$SMB_SHARE" -U "$SMB_DOMAIN/$SMB_USER%$SMB_PASS" -c "cd \"$REMOTE_BACKUP_PATH\"; ls" 2>/dev/null | grep -E "\.(dump|sql\.gz)$" | grep -v "postgres_globals_" | awk '{print $1}' | sed 's/_[0-9]\{8\}_[0-9]\{6\}\.\(dump\|sql\.gz\)$//' | sort -u || true)
        else
            remote_files=$(smbclient "//$SMB_SERVER/$SMB_SHARE" -U "$SMB_USER%$SMB_PASS" -c "cd \"$REMOTE_BACKUP_PATH\"; ls" 2>/dev/null | grep -E "\.(dump|sql\.gz)$" | grep -v "postgres_globals_" | awk '{print $1}' | sed 's/_[0-9]\{8\}_[0-9]\{6\}\.\(dump\|sql\.gz\)$//' | sort -u || true)
        fi
        echo "$remote_files"
    fi
}

# Parse command line arguments
DATABASE=""
BACKUP_FILE=""
USE_LATEST=false
USE_REMOTE=false
RESTORE_GLOBALS=false
RESTORE_ALL=false
HYDRATE=false
LIST_BACKUPS=false
LIST_REMOTE=false

while [[ $# -gt 0 ]]; do
    case $1 in
        -d|--database)
            DATABASE="$2"
            shift 2
            ;;
        -f|--file)
            BACKUP_FILE="$2"
            shift 2
            ;;
        -l|--latest)
            USE_LATEST=true
            shift
            ;;
        -r|--remote)
            USE_REMOTE=true
            shift
            ;;
        -g|--globals)
            RESTORE_GLOBALS=true
            shift
            ;;
        -a|--all)
            RESTORE_ALL=true
            shift
            ;;
        --hydrate)
            HYDRATE=true
            shift
            ;;
        --list-backups)
            LIST_BACKUPS=true
            shift
            ;;
        --list-remote)
            LIST_REMOTE=true
            shift
            ;;
        -h|--help)
            usage
            ;;
        *)
            echo "Unknown option: $1"
            usage
            ;;
    esac
done

# Handle list operations
if [ "$LIST_BACKUPS" = true ]; then
    list_backups
    exit 0
fi

if [ "$LIST_REMOTE" = true ]; then
    list_remote_backups
    exit 0
fi

# Main restore logic
if [ "$HYDRATE" = true ]; then
    # Hydrate mode: Restore globals + schema only (no data)
    if [ "$USE_LATEST" != true ]; then
        error_exit "Hydrate mode requires --latest flag"
    fi
    
    log "========================================="
    log "HYDRATE MODE: Restoring globals + schema"
    log "========================================="
    
    # Step 1: Restore globals
    log "Step 1/2: Restoring global objects..."
    if [ "$USE_REMOTE" = true ]; then
        latest_remote=$(find_latest_backup "postgres_globals" "remote")
        if [ -n "$latest_remote" ]; then
            downloaded_file=$(download_remote_backup "postgres_globals" "$latest_remote")
            restore_globals "$downloaded_file"
        else
            error_exit "No remote globals backup found"
        fi
    else
        latest_local=$(find "$BACKUP_DIR" -name "postgres_globals_*.sql.gz" -type f | sort | tail -n1)
        if [ -n "$latest_local" ]; then
            restore_globals "$latest_local"
        else
            error_exit "No local globals backup found"
        fi
    fi
    
    # Step 2: Restore all database schemas (no data)
    log "Step 2/2: Restoring database schemas (no data)..."
    location="local"
    [ "$USE_REMOTE" = true ] && location="remote"
    
    databases=$(get_all_databases "$location")
    if [ -z "$databases" ]; then
        error_exit "No database backups found"
    fi
    
    db_count=$(echo "$databases" | wc -l | tr -d ' ')
    current=0
    
    for db in $databases; do
        current=$((current + 1))
        log "Restoring schema [$current/$db_count]: $db"
        
        if [ "$USE_REMOTE" = true ]; then
            latest_remote=$(find_latest_backup "$db" "remote")
            if [ -n "$latest_remote" ]; then
                downloaded_file=$(download_remote_backup "$db" "$latest_remote")
                restore_database "$downloaded_file" true  # true = schema only
            else
                log "WARNING: No remote backup found for database: $db"
            fi
        else
            latest_local=$(find_latest_backup "$db" "local")
            if [ -n "$latest_local" ]; then
                restore_database "$latest_local" true  # true = schema only
            else
                log "WARNING: No local backup found for database: $db"
            fi
        fi
    done
    
    log "========================================="
    log "Hydrate complete: Globals + all schemas restored (no data)"
    log "========================================="
    
elif [ "$RESTORE_ALL" = true ]; then
    # Restore all databases (with data)
    if [ "$USE_LATEST" != true ]; then
        error_exit "Restore all mode requires --latest flag"
    fi
    
    log "========================================="
    log "FULL RESTORE: All databases"
    log "========================================="
    
    # Step 1: Restore globals
    log "Step 1/2: Restoring global objects..."
    if [ "$USE_REMOTE" = true ]; then
        latest_remote=$(find_latest_backup "postgres_globals" "remote")
        if [ -n "$latest_remote" ]; then
            downloaded_file=$(download_remote_backup "postgres_globals" "$latest_remote")
            restore_globals "$downloaded_file"
        else
            error_exit "No remote globals backup found"
        fi
    else
        latest_local=$(find "$BACKUP_DIR" -name "postgres_globals_*.sql.gz" -type f | sort | tail -n1)
        if [ -n "$latest_local" ]; then
            restore_globals "$latest_local"
        else
            error_exit "No local globals backup found"
        fi
    fi
    
    # Step 2: Restore all databases
    log "Step 2/2: Restoring all databases..."
    location="local"
    [ "$USE_REMOTE" = true ] && location="remote"
    
    databases=$(get_all_databases "$location")
    if [ -z "$databases" ]; then
        error_exit "No database backups found"
    fi
    
    db_count=$(echo "$databases" | wc -l | tr -d ' ')
    current=0
    
    for db in $databases; do
        current=$((current + 1))
        log "Restoring database [$current/$db_count]: $db"
        
        if [ "$USE_REMOTE" = true ]; then
            latest_remote=$(find_latest_backup "$db" "remote")
            if [ -n "$latest_remote" ]; then
                downloaded_file=$(download_remote_backup "$db" "$latest_remote")
                restore_database "$downloaded_file"
            else
                log "WARNING: No remote backup found for database: $db"
            fi
        else
            latest_local=$(find_latest_backup "$db" "local")
            if [ -n "$latest_local" ]; then
                restore_database "$latest_local"
            else
                log "WARNING: No local backup found for database: $db"
            fi
        fi
    done
    
    log "========================================="
    log "Full restore complete: $db_count databases restored"
    log "========================================="
    
elif [ "$RESTORE_GLOBALS" = true ]; then
    # Restore global objects only
    if [ "$USE_LATEST" = true ]; then
        if [ "$USE_REMOTE" = true ]; then
            # Find and download latest remote globals backup
            latest_remote=$(find_latest_backup "postgres_globals" "remote")
            if [ -n "$latest_remote" ]; then
                downloaded_file=$(download_remote_backup "postgres_globals" "$latest_remote")
                restore_globals "$downloaded_file"
            else
                error_exit "No remote globals backup found"
            fi
        else
            # Find latest local globals backup
            latest_local=$(find "$BACKUP_DIR" -name "postgres_globals_*.sql.gz" -type f | sort | tail -n1)
            if [ -n "$latest_local" ]; then
                restore_globals "$latest_local"
            else
                error_exit "No local globals backup found"
            fi
        fi
    elif [ -n "$BACKUP_FILE" ]; then
        restore_globals "$BACKUP_FILE"
    else
        error_exit "Must specify either --latest or --file with --globals"
    fi
elif [ -n "$BACKUP_FILE" ]; then
    # Restore specific file
    restore_database "$BACKUP_FILE"
elif [ -n "$DATABASE" ] && [ "$USE_LATEST" = true ]; then
    # Restore latest backup for database
    if [ "$USE_REMOTE" = true ]; then
        # Find and download latest remote backup
        latest_remote=$(find_latest_backup "$DATABASE" "remote")
        if [ -n "$latest_remote" ]; then
            downloaded_file=$(download_remote_backup "$DATABASE" "$latest_remote")
            restore_database "$downloaded_file"
        else
            error_exit "No remote backup found for database: $DATABASE"
        fi
    else
        # Find latest local backup
        latest_local=$(find_latest_backup "$DATABASE" "local")
        if [ -n "$latest_local" ]; then
            restore_database "$latest_local"
        else
            error_exit "No local backup found for database: $DATABASE"
        fi
    fi
else
    echo "Error: Missing required arguments"
    usage
fi

log "Restore process completed successfully"
